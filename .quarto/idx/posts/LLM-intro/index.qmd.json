{"title":"An Introduction to Large Language Models","markdown":{"yaml":{"title":"An Introduction to Large Language Models","date":"2023-10-30","author":"Pankaj Pansari"},"headingText":"1. Introduction","containsRefs":false,"markdown":"\n\n<div style=\"text-align: justify\"> \n<style>\n.center {\n    display: block;\n    margin-left: auto;\n    margin-right: auto;\n}\n</style>\n\n\n\nLarge language models (LLMs) are very large deep learning models that aim to predict and generate sensible text in a natural or symbolic human language. LLMs, in other words, are trained to model human language and even symbolic language such as code. We say that LLMs are trained for the task of language modeling.\n\nWe call models that can generate any form of content as generative models; for examples, models to generate images, videos, or music. Since LLMs generate text, they are also generative models.\n\nIn this blog post, we look at the difference between LLMs and earlier language models (LMs), we briefly review the architecture and training strategies for LLMs, and explain why they have been astoundingly successful at a wide variety of language tasks. We defer a detailed discussion of more fundamental technical topics such as language modeling, embeddings, and Transformer models to later blog posts. \n\n## 2. Background\n\n### 2.1 Language Modeling\n\nThe essence of tasks such as text translation, question-answering, making a chatbot is learning how to model human language. An LM is basically a probabilistic model that assigns a probability $$ P(w_1, w_2, \\dots, w_n) $$ to every finite sequence of words $w_1, \\dots, w_n$ (grammatical or not). This joint probability can be represented in terms of conditional probabilities as\n\n$$ P(w_1, w_2, \\dots, w_n) = P(w_1) \\times P(w_2|w_1) \\times P(w_3|w_1, w_2) \\dots \\times P(w_n|w_1, w_2, \\dots, w_{n-1}).$$\n\nHence, for the sentence \"I am going to the market\", we have\n\n$$P(\\text{I am going to the market}) = P(\\text{I}) \\times P(\\text{am|I}) \\times P(\\text{going|I am}) \\times P(\\text{to|I am going}) $$\n$$\\times P(\\text{the|I am going to}) \\times P(\\text{market|I am going to the}).$$\n\nHence, an LM needs to learn these conditional probabilities for many different groups of words and phrases. With a large text dataset at hand, this aim can be formulated as a machine learning task in two ways:\n\n- prediction of next word in the text given the previous words/phrases in a sentence; for example, \n\n<figure>\n    <img src=\"fig1.png\" class=\"center\" alt=\"A figure\" width = \"350\" height = \"200\">\n    <figcaption> Fig. 1 - Next word prediction </figcaption>\n</figure>\n\n- prediction of masked words or phrases given the rest of the words in the sentence (called *masked language modeling*); for example, \n\n<figure>\n    <img src=\"fig2.png\" class=\"center\" alt=\"A figure\" width = \"400\" height = \"200\">\n    <figcaption> Fig. 2 - Masked word prediction </figcaption>\n</figure>\n\nHence, the system creates its own prediction challenges from the text corpus. This learning paradigm where we don't provide explicit training labels is called *self-supervised learning*. Since we do away with the need for expensive labeling, use of large unlabeled text datasets, scraped from the Web, becomes possible. The concept is used not just in the domain of natural language processing (NLP), but for computer vision as well.\n\nPrediction of masked/next word(s) is powerful because doing it well calls for different kinds of understanding; every form of linguistic and world knowledge from grammar, sentence structure, word meaning, to facts help one to perform this task better. In performing language modeling, a model gathers a wide understanding of language and the world represented in the training corpus.\n\n### 2.1 Transformers\n\nTransformers are NLP models that take in text (a sequence of words) and output another text to perform some task such as translation or question-answering.\n\n#### 2.1.1. Embeddings\n\nAn embedding represents a word by a position in a real-valued vector space whose dimension can be in hundreds or thousands. The proximity of embeddings of two different words in this space in an indication of their semantic similarity.\n\n<figure>\n    <img src=\"fig3.png\" class=\"center\" alt=\"A figure\" width = \"400\" height = \"250\">\n    <figcaption> Fig. 3 - Schematic representations of embeddings in 2-dimension. Normally embeddings have many more dimensions. </figcaption>\n</figure>\n\n\n##### 2.1.2. Encoder-Decoder Models\n\nThe Transformer, at a high level, consists of two main components - an encoder and a decoder. The encoder takes in the word embeddings and transforms them by a sequence of operations to produce another set of 'encoded' embeddings. In each operation of that sequence, we allow the embeddings of all words to 'interact' and influence each other. The effect is that the new set of 'encoded embeddings' encapsulates higher-level context of the sentence.\n\nThe decoder takes in the set of embedded vectors to produce a sequence of real-valued vectors. Once we pass this sequence through a linear layer and softmax, we obtain the desired output. The softmax function normalizes the values in a vector to a probability distribution, bringing higher values closer to 1 and lower values to 0. \n\n<figure>\n    <img src=\"fig4.png\" class=\"center\" alt=\"A figure\" width = \"600\" height = \"250\">\n    <figcaption> Fig. 4 - Encoder-decoder model. \n</figure>\n\n\n#### 2.1.3. Self-attention\n\nAn key feature of Transformer models is their use of *attention* during the encoding and decoding phases. Attention layers are special architectural features that are present in encoder and decoder. In encoder, they enable the model to pay specific attention to certain words in the input sentence when trying to form a representation of each word. In decoder, they enable the model to pay attention to already produced output when generating the next output word.\n\nIt's clear that interpretation of words and phrases is context dependent and depends on the remaining words/phrases in the sentences. Crucially, we only need a few context words, and not the whole sentence, to determine the meaning/representation of a particular word. For example, the meaning of the word *bat* in *Cricket is played with a bat* can be inferred by looking at *Cricket* and that in *Bats are nocturnal creatures* by looking at *creatures*. \n\nAttention also lends itself to parallel computation, thereby boosting the speed at which powerful NLP models can be trained on GPUs.\n\n## 3. Large Language Models\n\nA machine learning model trained on vast quantity of data at scale (generally using self-supervision) can be adapted to a wide range of downstream tasks; such a model is called a *foundation model*. Large language models are a specific type of foundation model for NLP tasks and they make use of the Transformer architecture we discussed above. Some examples of LLMs are BERT, GPT-3, and T5.\n\nThough LLMs are based on the already established ideas of deep learning and self-supervised learning, it is the scale of these models and the datasets on which they are trained that make possible the astonishing performance on a wide variety of tasks. This scale is facilitated by improvements in computer hardware (GPU and memory), development of novel Transformer architecture, and the availability of huge datasets. Self-supervised learning is important to the ability to use huge data, since annotation is not required in this case.\n\nThe significance of foundation models lies in two concepts: *emergence* and *homogenization*. *Emergence* means that the foundation models with their billions of parameters can be adapted to a wide variety of tasks, through mere textual description of the task (prompts); that is, they are able to do *in-context learning* for many tasks for which they were neither trained nor anticipated to be used for. *Homogenization* means that there exists a handful of powerful base foundation models, such as BERT or T5, from which almost all state-of-the-art NLP models are derived through fine-tuning.\n\n### 3.1 Types of LLMs\n\nThe original Transformer architecture consists of two parts - encoder and decoder. Depending on the task at hand, researchers use either of the parts or both, giving rise to three types of LLMs:\n\n1. **Encoder-only LLMs** (eg. BERT) - This variant uses only the encoder part. It is designed to produce dense embeddings for the input word sequence. While pretraining using masked word prediction, one attaches an un-embedding layer, which produces one-hot encoded words. For downstream tasks, we remove the un-emdedding layer. A small task-specific model is trained on top of the encoder-only model making use of the embeddings. Such models are most suitable for tasks like missing word prediction and document classification.\n\n2. **Decoder-only LLMs** (eg. GPT)  - This variant uses only the decoder part of the Transformer. It is mainly used for text generation (output) from a given prompt (input). The input sequence or prompt is first encoded to a single large embedding from which the decoder outputs a sequence of words in an auto-regressive manner. *Auto-regression* means while generating a word, the model can refer to the previously generated words.\n\n3. **Encoder-decoder (eg. T5)** - This uses both encoder and decoder parts, making such a model quite large. It is used for tasks like language translation.\n\nWhile encoder-decoder models are generalizations of encoder-only and decoder-only, it's better to use smaller models with less parameters if the task calls for that. Encoder-only models are good for understanding tasks, decoder-only for generation tasks, and encoder-decoder for tasks where both inputs and outputs can be large sequences.\n\n### 3.2 Training LLMs\n\nLLMs typically follow the paradigm of pretraining and transfer learning.\n\n**Pretraining** - via self-supervised learning on a large textual corpus such as Wikipedia or GitHub. The resulting model is called *pre-trained language model* (PLM) and it can be adapted to a wide variety of downstream tasks. This is the part which takes a huge amount of training time and compute resources due to the size of the model and training data.\n\n**Transfer learning** - adapting the model to a specific task. Since the PLM has already acquired a lot of language and factual knowledge, this step needs a tiny amount of data and compute. This can be done via:\n\n1. **Fine-tuning** - The parameters of PLM are adjusted by training with additional data relevant to the application. These can be of 3 types:\n\n    a. Unsupervised: Suppose one is building a programming co-pilot using PLMs. The standard PLMs are usually pre-trained on internet text such as Wikipedia. We can now fine-tune them on code text, again using self-supervised learning.\n\n    b. Supervised: PLMs are pre-trained for next or masked word prediction. If we want to use them for, let's say, document sentiment analysis, we need to replace the output layer with a new one and train it with input-output pairs of texts and the associated sentiments.\n\n    c. Reinforcement Learning from Human Feedback (RLHF): This approach, mainly used by text generation models, consists of repeated execution of the following:\n\n        - The model is given a prompt and it generates multiple plausible answers.\n        - The different answers are ranked by a human from best to worst.\n        - The scores of the different answers are backpropagated.\n\n2. **Prompt engineering** - Fine-tuning used to be the only paradigm for transfer learning until recently. Now more powerful PLMs like GPT-3 only require a prompt and no explicit training (*zero-shot learning*) or a handful of examples (*few-shot learning*) to adapt to a new task.\n\n## 4. Challenges and Research Directions\n\n### 4.1 Multi-modality and Environment Interaction\n\nA lot of research work is being done currently on training foundation models using data from different modalities such as video and audio. By augmenting learning with multiple sensory data and knowledge, we provide stronger learning signals and increase learning speed.\n\nOne can also situate the foundation model in an environment where it can interact with other agents and objects; such models are called *embodied foundation models*. This can help the model learn cause and effect like humans by means of physically interacting with surroundings.\n\n### 4.2 Understanding and Intelligence\n\nThe impressive performance of LLMs on a wide variety of tasks, even on ones they were not trained for, has given rise to debates about whether or not these models are actually learn language in the way humans do [^4] or whether they are just elaborate rewriting systems devoid of meaning.\n\nThe first position seems partly convincing because state-of-the-art LLMs remain susceptible to unpredictable and unhumanlike intelligence. Sometimes LLMs generate text and responses that seem syntactically correct and natural but in reality they are incorrect factually - this is called *hallucination*.  \n\nOn the other hand, researchers argue that given the variety and difficulty of tasks multi-modal foundation models like GPT-4 can solve, we can confidently say they exhibit aspects of intelligence[^2]. There's been some recent work on understanding in-context learning which posits that perhaps these large foundation models have smaller machine-learning models inside them that the big model can train to perform a new task[^3]. Clearly, some aspects of LLM behavior indeed seem intelligent, but not exactly in human way; this calls for a rethinking and expansion of the meaning of intelligence.\n\n### 4.3 Alignment\n\n*Alignment* refers to the process of ensuring that LLMs behave in harmony with human values and preferences. An *aligned* LLM is trustworthy. The characteristics needed for an LLM to be used with trust in the real-world are reliability, safety, fairness, resistance to misuse, explainability, and robustness [^6]. Out of these, here we only consider fairness.\n\n**Fairness** - Due to the huge size of training data and LLMs, we don't clealy understand the biases encapsulated in these models nor have an estimate of safety for use in critical applications. Homogenization is also a liability, since all derived NLP models may inherit the same harmful biases of a few foundation models. This calls for investing significant resources into curating and documenting LLM training data. \n\nAnother concern is that with more widespread use of LLMs, more content on the web is likely to be LLM-generated. When future models are trained on web data, bias is likely to be propagated and the models can become less capable - a phenomenon known as *model collapse* [^5].\n\n[^2]: Bubeck, SÃ©bastien, et al. \"Sparks of artificial general intelligence: Early experiments with gpt-4.\" arXiv preprint arXiv:2303.12712 (2023). \n[^3]: AkyÃ¼rek, Ekin, et al. \"What learning algorithm is in-context learning? investigations with linear models.\" arXiv preprint arXiv:2211.15661 (2022). \n[^4]: Bender, Emily M., et al. \"On the dangers of stochastic parrots: Can language models be too big?ðŸ¦œ.\" Proceedings of the 2021 ACM conference on fairness, accountability, and transparency. 2021.\n[^5]: Shumailov, Ilia, et al. \"The Curse of Recursion: Training on Generated Data Makes Models Forget\" arXiv preprint 2305.17493\n[^6]: Liu, Yang, et al. \"Trustworthy LLMs: a Survey and Guideline for Evaluating Large Language Models' Alignment.\" arXiv preprint arXiv:2308.05374 (2023).\n\n</div>\n","srcMarkdownNoYaml":"\n\n<div style=\"text-align: justify\"> \n<style>\n.center {\n    display: block;\n    margin-left: auto;\n    margin-right: auto;\n}\n</style>\n\n\n## 1. Introduction\n\nLarge language models (LLMs) are very large deep learning models that aim to predict and generate sensible text in a natural or symbolic human language. LLMs, in other words, are trained to model human language and even symbolic language such as code. We say that LLMs are trained for the task of language modeling.\n\nWe call models that can generate any form of content as generative models; for examples, models to generate images, videos, or music. Since LLMs generate text, they are also generative models.\n\nIn this blog post, we look at the difference between LLMs and earlier language models (LMs), we briefly review the architecture and training strategies for LLMs, and explain why they have been astoundingly successful at a wide variety of language tasks. We defer a detailed discussion of more fundamental technical topics such as language modeling, embeddings, and Transformer models to later blog posts. \n\n## 2. Background\n\n### 2.1 Language Modeling\n\nThe essence of tasks such as text translation, question-answering, making a chatbot is learning how to model human language. An LM is basically a probabilistic model that assigns a probability $$ P(w_1, w_2, \\dots, w_n) $$ to every finite sequence of words $w_1, \\dots, w_n$ (grammatical or not). This joint probability can be represented in terms of conditional probabilities as\n\n$$ P(w_1, w_2, \\dots, w_n) = P(w_1) \\times P(w_2|w_1) \\times P(w_3|w_1, w_2) \\dots \\times P(w_n|w_1, w_2, \\dots, w_{n-1}).$$\n\nHence, for the sentence \"I am going to the market\", we have\n\n$$P(\\text{I am going to the market}) = P(\\text{I}) \\times P(\\text{am|I}) \\times P(\\text{going|I am}) \\times P(\\text{to|I am going}) $$\n$$\\times P(\\text{the|I am going to}) \\times P(\\text{market|I am going to the}).$$\n\nHence, an LM needs to learn these conditional probabilities for many different groups of words and phrases. With a large text dataset at hand, this aim can be formulated as a machine learning task in two ways:\n\n- prediction of next word in the text given the previous words/phrases in a sentence; for example, \n\n<figure>\n    <img src=\"fig1.png\" class=\"center\" alt=\"A figure\" width = \"350\" height = \"200\">\n    <figcaption> Fig. 1 - Next word prediction </figcaption>\n</figure>\n\n- prediction of masked words or phrases given the rest of the words in the sentence (called *masked language modeling*); for example, \n\n<figure>\n    <img src=\"fig2.png\" class=\"center\" alt=\"A figure\" width = \"400\" height = \"200\">\n    <figcaption> Fig. 2 - Masked word prediction </figcaption>\n</figure>\n\nHence, the system creates its own prediction challenges from the text corpus. This learning paradigm where we don't provide explicit training labels is called *self-supervised learning*. Since we do away with the need for expensive labeling, use of large unlabeled text datasets, scraped from the Web, becomes possible. The concept is used not just in the domain of natural language processing (NLP), but for computer vision as well.\n\nPrediction of masked/next word(s) is powerful because doing it well calls for different kinds of understanding; every form of linguistic and world knowledge from grammar, sentence structure, word meaning, to facts help one to perform this task better. In performing language modeling, a model gathers a wide understanding of language and the world represented in the training corpus.\n\n### 2.1 Transformers\n\nTransformers are NLP models that take in text (a sequence of words) and output another text to perform some task such as translation or question-answering.\n\n#### 2.1.1. Embeddings\n\nAn embedding represents a word by a position in a real-valued vector space whose dimension can be in hundreds or thousands. The proximity of embeddings of two different words in this space in an indication of their semantic similarity.\n\n<figure>\n    <img src=\"fig3.png\" class=\"center\" alt=\"A figure\" width = \"400\" height = \"250\">\n    <figcaption> Fig. 3 - Schematic representations of embeddings in 2-dimension. Normally embeddings have many more dimensions. </figcaption>\n</figure>\n\n\n##### 2.1.2. Encoder-Decoder Models\n\nThe Transformer, at a high level, consists of two main components - an encoder and a decoder. The encoder takes in the word embeddings and transforms them by a sequence of operations to produce another set of 'encoded' embeddings. In each operation of that sequence, we allow the embeddings of all words to 'interact' and influence each other. The effect is that the new set of 'encoded embeddings' encapsulates higher-level context of the sentence.\n\nThe decoder takes in the set of embedded vectors to produce a sequence of real-valued vectors. Once we pass this sequence through a linear layer and softmax, we obtain the desired output. The softmax function normalizes the values in a vector to a probability distribution, bringing higher values closer to 1 and lower values to 0. \n\n<figure>\n    <img src=\"fig4.png\" class=\"center\" alt=\"A figure\" width = \"600\" height = \"250\">\n    <figcaption> Fig. 4 - Encoder-decoder model. \n</figure>\n\n\n#### 2.1.3. Self-attention\n\nAn key feature of Transformer models is their use of *attention* during the encoding and decoding phases. Attention layers are special architectural features that are present in encoder and decoder. In encoder, they enable the model to pay specific attention to certain words in the input sentence when trying to form a representation of each word. In decoder, they enable the model to pay attention to already produced output when generating the next output word.\n\nIt's clear that interpretation of words and phrases is context dependent and depends on the remaining words/phrases in the sentences. Crucially, we only need a few context words, and not the whole sentence, to determine the meaning/representation of a particular word. For example, the meaning of the word *bat* in *Cricket is played with a bat* can be inferred by looking at *Cricket* and that in *Bats are nocturnal creatures* by looking at *creatures*. \n\nAttention also lends itself to parallel computation, thereby boosting the speed at which powerful NLP models can be trained on GPUs.\n\n## 3. Large Language Models\n\nA machine learning model trained on vast quantity of data at scale (generally using self-supervision) can be adapted to a wide range of downstream tasks; such a model is called a *foundation model*. Large language models are a specific type of foundation model for NLP tasks and they make use of the Transformer architecture we discussed above. Some examples of LLMs are BERT, GPT-3, and T5.\n\nThough LLMs are based on the already established ideas of deep learning and self-supervised learning, it is the scale of these models and the datasets on which they are trained that make possible the astonishing performance on a wide variety of tasks. This scale is facilitated by improvements in computer hardware (GPU and memory), development of novel Transformer architecture, and the availability of huge datasets. Self-supervised learning is important to the ability to use huge data, since annotation is not required in this case.\n\nThe significance of foundation models lies in two concepts: *emergence* and *homogenization*. *Emergence* means that the foundation models with their billions of parameters can be adapted to a wide variety of tasks, through mere textual description of the task (prompts); that is, they are able to do *in-context learning* for many tasks for which they were neither trained nor anticipated to be used for. *Homogenization* means that there exists a handful of powerful base foundation models, such as BERT or T5, from which almost all state-of-the-art NLP models are derived through fine-tuning.\n\n### 3.1 Types of LLMs\n\nThe original Transformer architecture consists of two parts - encoder and decoder. Depending on the task at hand, researchers use either of the parts or both, giving rise to three types of LLMs:\n\n1. **Encoder-only LLMs** (eg. BERT) - This variant uses only the encoder part. It is designed to produce dense embeddings for the input word sequence. While pretraining using masked word prediction, one attaches an un-embedding layer, which produces one-hot encoded words. For downstream tasks, we remove the un-emdedding layer. A small task-specific model is trained on top of the encoder-only model making use of the embeddings. Such models are most suitable for tasks like missing word prediction and document classification.\n\n2. **Decoder-only LLMs** (eg. GPT)  - This variant uses only the decoder part of the Transformer. It is mainly used for text generation (output) from a given prompt (input). The input sequence or prompt is first encoded to a single large embedding from which the decoder outputs a sequence of words in an auto-regressive manner. *Auto-regression* means while generating a word, the model can refer to the previously generated words.\n\n3. **Encoder-decoder (eg. T5)** - This uses both encoder and decoder parts, making such a model quite large. It is used for tasks like language translation.\n\nWhile encoder-decoder models are generalizations of encoder-only and decoder-only, it's better to use smaller models with less parameters if the task calls for that. Encoder-only models are good for understanding tasks, decoder-only for generation tasks, and encoder-decoder for tasks where both inputs and outputs can be large sequences.\n\n### 3.2 Training LLMs\n\nLLMs typically follow the paradigm of pretraining and transfer learning.\n\n**Pretraining** - via self-supervised learning on a large textual corpus such as Wikipedia or GitHub. The resulting model is called *pre-trained language model* (PLM) and it can be adapted to a wide variety of downstream tasks. This is the part which takes a huge amount of training time and compute resources due to the size of the model and training data.\n\n**Transfer learning** - adapting the model to a specific task. Since the PLM has already acquired a lot of language and factual knowledge, this step needs a tiny amount of data and compute. This can be done via:\n\n1. **Fine-tuning** - The parameters of PLM are adjusted by training with additional data relevant to the application. These can be of 3 types:\n\n    a. Unsupervised: Suppose one is building a programming co-pilot using PLMs. The standard PLMs are usually pre-trained on internet text such as Wikipedia. We can now fine-tune them on code text, again using self-supervised learning.\n\n    b. Supervised: PLMs are pre-trained for next or masked word prediction. If we want to use them for, let's say, document sentiment analysis, we need to replace the output layer with a new one and train it with input-output pairs of texts and the associated sentiments.\n\n    c. Reinforcement Learning from Human Feedback (RLHF): This approach, mainly used by text generation models, consists of repeated execution of the following:\n\n        - The model is given a prompt and it generates multiple plausible answers.\n        - The different answers are ranked by a human from best to worst.\n        - The scores of the different answers are backpropagated.\n\n2. **Prompt engineering** - Fine-tuning used to be the only paradigm for transfer learning until recently. Now more powerful PLMs like GPT-3 only require a prompt and no explicit training (*zero-shot learning*) or a handful of examples (*few-shot learning*) to adapt to a new task.\n\n## 4. Challenges and Research Directions\n\n### 4.1 Multi-modality and Environment Interaction\n\nA lot of research work is being done currently on training foundation models using data from different modalities such as video and audio. By augmenting learning with multiple sensory data and knowledge, we provide stronger learning signals and increase learning speed.\n\nOne can also situate the foundation model in an environment where it can interact with other agents and objects; such models are called *embodied foundation models*. This can help the model learn cause and effect like humans by means of physically interacting with surroundings.\n\n### 4.2 Understanding and Intelligence\n\nThe impressive performance of LLMs on a wide variety of tasks, even on ones they were not trained for, has given rise to debates about whether or not these models are actually learn language in the way humans do [^4] or whether they are just elaborate rewriting systems devoid of meaning.\n\nThe first position seems partly convincing because state-of-the-art LLMs remain susceptible to unpredictable and unhumanlike intelligence. Sometimes LLMs generate text and responses that seem syntactically correct and natural but in reality they are incorrect factually - this is called *hallucination*.  \n\nOn the other hand, researchers argue that given the variety and difficulty of tasks multi-modal foundation models like GPT-4 can solve, we can confidently say they exhibit aspects of intelligence[^2]. There's been some recent work on understanding in-context learning which posits that perhaps these large foundation models have smaller machine-learning models inside them that the big model can train to perform a new task[^3]. Clearly, some aspects of LLM behavior indeed seem intelligent, but not exactly in human way; this calls for a rethinking and expansion of the meaning of intelligence.\n\n### 4.3 Alignment\n\n*Alignment* refers to the process of ensuring that LLMs behave in harmony with human values and preferences. An *aligned* LLM is trustworthy. The characteristics needed for an LLM to be used with trust in the real-world are reliability, safety, fairness, resistance to misuse, explainability, and robustness [^6]. Out of these, here we only consider fairness.\n\n**Fairness** - Due to the huge size of training data and LLMs, we don't clealy understand the biases encapsulated in these models nor have an estimate of safety for use in critical applications. Homogenization is also a liability, since all derived NLP models may inherit the same harmful biases of a few foundation models. This calls for investing significant resources into curating and documenting LLM training data. \n\nAnother concern is that with more widespread use of LLMs, more content on the web is likely to be LLM-generated. When future models are trained on web data, bias is likely to be propagated and the models can become less capable - a phenomenon known as *model collapse* [^5].\n\n[^2]: Bubeck, SÃ©bastien, et al. \"Sparks of artificial general intelligence: Early experiments with gpt-4.\" arXiv preprint arXiv:2303.12712 (2023). \n[^3]: AkyÃ¼rek, Ekin, et al. \"What learning algorithm is in-context learning? investigations with linear models.\" arXiv preprint arXiv:2211.15661 (2022). \n[^4]: Bender, Emily M., et al. \"On the dangers of stochastic parrots: Can language models be too big?ðŸ¦œ.\" Proceedings of the 2021 ACM conference on fairness, accountability, and transparency. 2021.\n[^5]: Shumailov, Ilia, et al. \"The Curse of Recursion: Training on Generated Data Makes Models Forget\" arXiv preprint 2305.17493\n[^6]: Liu, Yang, et al. \"Trustworthy LLMs: a Survey and Guideline for Evaluating Large Language Models' Alignment.\" arXiv preprint arXiv:2308.05374 (2023).\n\n</div>\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.551","theme":"cosmo","title-block-banner":true,"title":"An Introduction to Large Language Models","date":"2023-10-30","author":"Pankaj Pansari"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}