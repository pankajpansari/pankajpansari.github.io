{"title":"A Simple Painting Style Classifier","markdown":{"yaml":{"title":"A Simple Painting Style Classifier","date":"2023-02-13","author":"Pankaj Pansari","draft":true},"headingText":"Motivation","containsRefs":false,"markdown":"\n\nAs a first project for my portfolio, I decided to build a simple deep learning model which can classify paintings based on their styles. As of now, the model supports only binary classification - impressionism and cubism. This project involved the whole end-to-end process - data collection, data cleaning and transformation, model training and testing, and finally deploying it as a web application.\n\n\nThe motivation for this project came from [an online course](https://www.w3schools.io/file/markdown-links/) on deep learning which I'm currently following (particularly Chapters 1 and 2). In it, the instructor shows how to build an image classifier for a simple task - identifying whether the given image is of a dog or a cat. He then shows how to host the model on a server and deploy it using a basic web application. I decided to adapt the process to my personal interest. I enjoy visiting art museums and looking at paintings. I thought I'd build a painting style identifier. I initially started with only two types - [impressionism](https://en.wikipedia.org/wiki/Impressionism) and [cubism](https://en.wikipedia.org/wiki/Cubism), because the two styles have such strong characteristics and hence are easy to distinguish by humans.\n\n## Data Collection and Processing\n\nI began the project on [Google Colab](https://colab.research.google.com/drive/1v_7Yltc3fBvDRao-ithQdOeoZ5_Oqoez?usp=sharing) using Jupyter notebook. Colab provides free GPU for our model training and Jupyter notebook is helpful for prototyping and quickly visualisation of results. Image collection was done using DuckDuckGo search API. Microsoft Bing API is probably better in terms of providing more relevant images, but inovlves some knotty configuration. I collected 90 images of each class - a small but sufficient dataset because instead of training an image classifier from scratch, I fine-tuned a powerful model trained on a large dataset. \n\nThere is some preprocessing to be done before we can use our image data:\n\n1. Image resizing - The images we've scrapped are of different sizes. However, our deep learning model expects all images in the dataset to have the same size. Image resizing can be done in multiple ways. Here I chose [random cropping](https://blog.roboflow.com/why-and-how-to-implement-random-crop-data-augmentation/). On each epoch (which is one complete pass through all of our images in the dataset) we randomly select a 224x224 patch of each image. This method has the advantage that by the end of training, we would've used information from all parts of the image and would not have arbitrarily distorted the images. This process is also augments the dataset since each image can yield muliple cropped samples.\n\n2. Data augmentation - To increase the size of the dataset and to make our model our robust, each image can be flipped, rotated, warped and have brightness and contrast changed.\n\nBoth of these above functionalities are provided by the [fastai library](https://docs.fast.ai/). fastai is a high-level Python library for deep learning built on top of PyTorch that makes the whole process of data cleaning, training, and testing both easier and faster. \n\n## Model Training\n\nI bypassed image cleaning and decided to directly train a deep learning model. I used a [ResNet model](https://towardsdatascience.com/review-resnet-winner-of-ilsvrc-2015-image-classification-localization-detection-e39402bfa5d8) with 34 layers, pretrained on the ImageNet dataset to perform image classification. This model is provided for use via fastai. Since the model is already pre-trained, we only have to fine-tune it for our style classification task. Using a pre-trained model meant that I did not need a huge amount of training data or computing resource/time.\n\nfastai provides a very useful function that suggests a good learning rate to use for training. I fined-tuned the model with the suggested learning rate.\n\n## Model Validation and Training\n\nThe error on the validation set during training goes down to zero completely. I looked at some of the outputs from the model and saw that they're correctly classified.\n\nI also tested the model on a couple of hand-picked images and visualized the responses.\n\n## Deployment as a Web Application\n\nI exported and saved the model from the Colab notebook. I used [Gradio](https://www.gradio.app/) to demo my model as a web app. It wraps a python function into a user interface and allows us to launch the demos inside jupyter notebooks. The model was hosted on [Hugging Face Spaces](https://huggingface.co/docs/hub/spaces).\n\nFinally to create the web application, I used a JavaScript program that accepts the uploaded image, calls the gradio function for inference, and displays the returned results.\n\n## Further Work\n\nI tried extending this model to identify more types of painting styles. I'm not an art expert, so after some online research I decided to use 9 different painting styles that are considered the most important. Despite trying various different training parameters, I couldn't get the final model to be accurate enough. \n\nA visualisation of the images where the model performed poorly revealed that some of the images scrapped via the DuckDuckGo API were irrelevant and had to be removed. fastai provides a way for us to remove these irrelevant data via a GUI interface. I did this and still the accuracy was poor. I began to suspect that the images returned in response to search queries didn't actually belong to the right styles. All of this suggested that I needed a better way to build up a cleaner and more accurate dataset. However, this process is going to be time-consuming and hence I've decided to postpone it for a later iteration.\n\n\n\n\n","srcMarkdownNoYaml":"\n\nAs a first project for my portfolio, I decided to build a simple deep learning model which can classify paintings based on their styles. As of now, the model supports only binary classification - impressionism and cubism. This project involved the whole end-to-end process - data collection, data cleaning and transformation, model training and testing, and finally deploying it as a web application.\n\n## Motivation\n\nThe motivation for this project came from [an online course](https://www.w3schools.io/file/markdown-links/) on deep learning which I'm currently following (particularly Chapters 1 and 2). In it, the instructor shows how to build an image classifier for a simple task - identifying whether the given image is of a dog or a cat. He then shows how to host the model on a server and deploy it using a basic web application. I decided to adapt the process to my personal interest. I enjoy visiting art museums and looking at paintings. I thought I'd build a painting style identifier. I initially started with only two types - [impressionism](https://en.wikipedia.org/wiki/Impressionism) and [cubism](https://en.wikipedia.org/wiki/Cubism), because the two styles have such strong characteristics and hence are easy to distinguish by humans.\n\n## Data Collection and Processing\n\nI began the project on [Google Colab](https://colab.research.google.com/drive/1v_7Yltc3fBvDRao-ithQdOeoZ5_Oqoez?usp=sharing) using Jupyter notebook. Colab provides free GPU for our model training and Jupyter notebook is helpful for prototyping and quickly visualisation of results. Image collection was done using DuckDuckGo search API. Microsoft Bing API is probably better in terms of providing more relevant images, but inovlves some knotty configuration. I collected 90 images of each class - a small but sufficient dataset because instead of training an image classifier from scratch, I fine-tuned a powerful model trained on a large dataset. \n\nThere is some preprocessing to be done before we can use our image data:\n\n1. Image resizing - The images we've scrapped are of different sizes. However, our deep learning model expects all images in the dataset to have the same size. Image resizing can be done in multiple ways. Here I chose [random cropping](https://blog.roboflow.com/why-and-how-to-implement-random-crop-data-augmentation/). On each epoch (which is one complete pass through all of our images in the dataset) we randomly select a 224x224 patch of each image. This method has the advantage that by the end of training, we would've used information from all parts of the image and would not have arbitrarily distorted the images. This process is also augments the dataset since each image can yield muliple cropped samples.\n\n2. Data augmentation - To increase the size of the dataset and to make our model our robust, each image can be flipped, rotated, warped and have brightness and contrast changed.\n\nBoth of these above functionalities are provided by the [fastai library](https://docs.fast.ai/). fastai is a high-level Python library for deep learning built on top of PyTorch that makes the whole process of data cleaning, training, and testing both easier and faster. \n\n## Model Training\n\nI bypassed image cleaning and decided to directly train a deep learning model. I used a [ResNet model](https://towardsdatascience.com/review-resnet-winner-of-ilsvrc-2015-image-classification-localization-detection-e39402bfa5d8) with 34 layers, pretrained on the ImageNet dataset to perform image classification. This model is provided for use via fastai. Since the model is already pre-trained, we only have to fine-tune it for our style classification task. Using a pre-trained model meant that I did not need a huge amount of training data or computing resource/time.\n\nfastai provides a very useful function that suggests a good learning rate to use for training. I fined-tuned the model with the suggested learning rate.\n\n## Model Validation and Training\n\nThe error on the validation set during training goes down to zero completely. I looked at some of the outputs from the model and saw that they're correctly classified.\n\nI also tested the model on a couple of hand-picked images and visualized the responses.\n\n## Deployment as a Web Application\n\nI exported and saved the model from the Colab notebook. I used [Gradio](https://www.gradio.app/) to demo my model as a web app. It wraps a python function into a user interface and allows us to launch the demos inside jupyter notebooks. The model was hosted on [Hugging Face Spaces](https://huggingface.co/docs/hub/spaces).\n\nFinally to create the web application, I used a JavaScript program that accepts the uploaded image, calls the gradio function for inference, and displays the returned results.\n\n## Further Work\n\nI tried extending this model to identify more types of painting styles. I'm not an art expert, so after some online research I decided to use 9 different painting styles that are considered the most important. Despite trying various different training parameters, I couldn't get the final model to be accurate enough. \n\nA visualisation of the images where the model performed poorly revealed that some of the images scrapped via the DuckDuckGo API were irrelevant and had to be removed. fastai provides a way for us to remove these irrelevant data via a GUI interface. I did this and still the accuracy was poor. I began to suspect that the images returned in response to search queries didn't actually belong to the right styles. All of this suggested that I needed a better way to build up a cleaner and more accurate dataset. However, this process is going to be time-consuming and hence I've decided to postpone it for a later iteration.\n\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.43","theme":"cosmo","title-block-banner":true,"title":"A Simple Painting Style Classifier","date":"2023-02-13","author":"Pankaj Pansari","draft":true},"extensions":{"book":{"multiFile":true}}}},"draft":true,"projectFormats":["html"]}